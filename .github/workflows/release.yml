name: Release

on:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  checks:
    runs-on: ubuntu-22.04
    steps:
      - name: Verify branch
        if: github.ref_name != 'dev' && github.ref_name != 'hotfix'
        run: |
          echo "::error::This workflow can only be run from dev or hotfix branches"
          exit 1

      - name: Check workflow status
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              status: 'in_progress',
            });

            // "release.yml" is checked using the concurrency group at the top of this file
            const workflows = [
              '.github/workflows/merge-to-dev-or-hotfix.yml',
              '.github/workflows/tag-push.yml',
            ];

            const running = data.workflow_runs
              .filter(run => workflows.some(w => run.path.startsWith(w)));

            if (running.length > 0) {
              core.setFailed(`Workflows currently running: ${running.join(', ')}. Please retry after they complete.`);
            }

  release:
    needs: checks
    runs-on: ubuntu-22.04
    environment: production
    steps:
      - name: Create deployer app token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ secrets.DEPLOYER_APP_ID }}
          private-key: ${{ secrets.DEPLOYER_APP_PK }}

      - uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}
          ref: master
          fetch-depth: 0

      - name: Find tags to release
        id: find-tags
        run: |
          git fetch origin ${{ github.ref_name }} --tags

          # Tags on source but not master, sorted descending; first per app is latest
          RELEASE_TAGS=$(git tag --merged origin/${{ github.ref_name }} --no-merged master --sort=-version:refname \
            | grep '@' \
            | awk -F'@' '!seen[$1]++')

          # Build release data (line-based: APP TAG VERSION IMAGE_TAG)
          RELEASES=""
          for TAG in $RELEASE_TAGS; do
            APP="${TAG%%@*}"
            VERSION="${TAG#*@}"
            SHA=$(git rev-parse --short "${TAG}^{commit}")
            RELEASES+="${APP} ${TAG} ${VERSION} ${VERSION}-${SHA}"$'\n'
          done
          echo "releases<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "Found releases:"
          echo "$RELEASES"

      - name: Fast-forward to master
        run: git merge origin/${{ github.ref_name }} --ff-only

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Tag Docker images as latest
        run: |
          while read APP TAG VERSION IMAGE_TAG; do
            [[ -z "$APP" ]] && continue
            IMAGE=$(echo "ghcr.io/nexusmutual/${APP}" | tr '[:upper:]' '[:lower:]')
            docker pull "${IMAGE}:${IMAGE_TAG}"
            docker tag "${IMAGE}:${IMAGE_TAG}" "${IMAGE}:latest"
            docker push "${IMAGE}:latest"
          done <<< "${{ steps.find-tags.outputs.releases }}"

      - name: Create GitHub releases
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          while read APP TAG VERSION IMAGE_TAG; do
            [[ -z "$APP" ]] && continue
            if ! gh release view "$TAG" >/dev/null 2>&1; then
              gh release create "$TAG" --title "${APP} v${VERSION}" --generate-notes --target master
            fi
          done <<< "${{ steps.find-tags.outputs.releases }}"

      - name: Push master to origin
        run: git push origin master
